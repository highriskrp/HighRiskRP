
--- FreameWork Notify ---

FreamworkNotify = function(source, message, notifyType, length)
  notifyType = notifyType or "success"
  length = length or 5000
  TriggerClientEvent('QBCore:Notify', source, message, notifyType, length)
end

--- Phone Unique ID ---

local function randomString(length)
  local chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
  local result = ''
  for _ = 1, length do
      local rand = math.random(#chars)
      result = result .. chars:sub(rand, rand)
  end
  return result
end

-- Generates a unique serial number for the phone.
-- The serial number is generated by combining a prefix, the current date, and a random string.
-- The generated serial number is checked against the database to ensure its uniqueness.
-- If a duplicate serial number is found, the function will generate a new one.
-- Returns the generated serial number.
function generateSerialNumber()
  :: generateSerial ::
  local prefix = Config.SerialNumberPrefix
  local date = os.date("%Y%m")
  local serial = randomString(4)
  local serialNumber = prefix .. date .. serial
  local result = MySQL.Sync.fetchScalar('SELECT COUNT(*) FROM gksphone_settings WHERE unique_id = ?', {serialNumber})
  if result > 0 then
    goto generateSerial
  end
  return serialNumber
end

--- Create Phone Number ---

-- Creates a unique phone number by generating a random 8-digit number and checking if it already exists in the database.
-- If the generated number already exists, it generates a new number until a unique one is found.
-- Returns the generated phone number as a string.
function CreatePhoneNumber()
  :: createNumber ::
  local PhoneNumber = math.random(10000000, 99999999)
  local query = '%' .. PhoneNumber .. '%'
  local result = MySQL.Sync.fetchScalar('SELECT COUNT(*) FROM gksphone_esim WHERE phone_number LIKE ?', { query })
  if result > 0 then
    goto createNumber
  end
  return tostring(PhoneNumber)
end

--- Society Money ----

function SocietyGetMoney(jobname)
  local BusinessMoney = 0
  if GetResourceState("qb-banking") == "started" then
    BusinessMoney = exports['qb-banking']:GetAccount(jobname)?.account_balance or 0
  end

  return BusinessMoney
end

function SocietyRemoveMoney(job, amount)
  local process = false
  if GetResourceState("qb-banking") == "started" then
    local jobPrice = SocietyGetMoney(job)
    if jobPrice >= amount then
      if exports['qb-banking']:RemoveMoney(job, amount) then
        process = true
      end
    end
  end
  return process
end

function SocietyAddMoney(job, amount)
  local process = false
  if GetResourceState("qb-banking") == "started" then
    if exports['qb-banking']:AddMoney(job, amount) then
      process = true
    end
  end
  return process
end

---- IsDead Inlaststand ---

function CallingPlayerStatus(source)
  local retval = false
  local Player = Config.Core.Functions.GetPlayer(source)
  if Player.PlayerData.metadata["ishandcuffed"] or Player.PlayerData.metadata["isdead"] or Player.PlayerData.metadata["inlaststand"] then
    retval = true
  end
  return retval
end

--- Auto Open Close Dispatch ---

if Config.IsDispatchAutoOpenClose then
  RegisterNetEvent('QBCore:Server:OnJobUpdate', function(source, newJob)
    local IgnorCheck = false
    local jobCode = ""
    for k, v in pairs(Config.JOBDispatch) do
      if k == newJob.name then
        if Config.DispatchAutoIgnoredJobs[k] then
          IgnorCheck = true
          jobCode = k
          break
        end
      end
      if v.alternativejobs then
        for x, m in pairs(v.alternativejobs) do
          if x == newJob.name and m then
            if Config.DispatchAutoIgnoredJobs[k] then
              IgnorCheck = true
              jobCode = k
              break
            end
          end
        end
      end
    end
    if not Config.JOBDispatch[jobCode] or IgnorCheck then return end
    local _, count = Config.Core.Functions.GetPlayersOnDuty(jobCode)
    if jobCode ~= newJob.name then
      local alternativejobs = Config.JOBDispatch[jobCode]?.alternativejobs
      if alternativejobs then
        for x, m in pairs(alternativejobs) do
          if x and m then
            local _, countCheck = Config.Core.Functions.GetPlayersOnDuty(x)
            count += countCheck
          end
        end
      end
    end
    if count == 0 then
      local isJobActive = exports["gksphone"]:IsJobStatus(jobCode)
      if isJobActive then
        exports["gksphone"]:JobStatusChange(jobCode, false)
      end
    elseif count == 1 then
      local isJobActive = exports["gksphone"]:IsJobStatus(jobCode)
      if not isJobActive then
        exports["gksphone"]:JobStatusChange(jobCode, true)
      end
    end
  end)
end

--- Delete Character ---
--- Delete Character Event ---
if Config.deleteCharacter then
  RegisterNetEvent("qb-multicharacter:server:deleteCharacter", function (citizenid)
    DeleteCharacter(citizenid)
  end)
end


--- HasPhoneItem ---
--- Check if the player has a phone item in their inventory.

function HasPhoneItem(source)
  local src = source
  local Player = Config.Core.Functions.GetPlayer(src)
  local itemData = {}
  if Player then
      for k, _ in pairs(Config.ItemName) do
          local itemCheck = Player.Functions.GetItemsByName(k)
          if itemCheck and #itemCheck > 0 then
              itemData = itemCheck
              break
          end
      end
      if #itemData > 0 then
          return itemData
      end
  end
  return itemData
end